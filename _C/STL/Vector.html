---
layout: General
title: Contenedor Vector
---

<p>
	El elemento <code>vector</code> es un contenedor que funciona como un arreglo de tamaño dinámico.
</p>
<ul class="ListaContenido">
	<li id="1L"><span>Funcionamiento</span></li>
	<li id="2L"><span>Eficiencia</span></li>
	<li id="3L"><span>Funciones miembro</span></li>
	<li id="4L"><span>Funciones no miembro</span></li>
	<li id="5L"><span>Ejemplo general</span></li>
</ul>

<div class="Subtitulo" id="1">
	Funcionamiento
</div>
<p>
	Los elementos dentro de <code>vector</code> son almacenados de manera contigua (<int>como en un arreglo</int>) por lo tanto, se puede acceder a cada elemento usando <i>iteradores</i> o también los punteros regulares que usamos en los arreglos <code>[ ]</code>, de esta manera, podemos decir que podemos <i>hacer referencias</i> a un <code>vector</code>, de manera muy similar a como lo hacemos en un arreglo estático.
</p>
<p>
	La capacidad de <code>vector</code> es manejada de manera automática, por lo que crece o disminuye según sea necesario. Es decir, cuando declaramos un arreglo tradicional, declaramos también la capacidad de éste. Con un contenedor <code>vector</code> no es necesario especificar el tamaño. Pues crece o se minimiza según se vaya necesitando.
</p>
<p>
	La capacidad total de un contenedor de este tipo, es variada, pero puede ser solicitada usando la función <code>capacity()</code>
</p>

<div class="Subtitulo" id="2">
	Eficiencia
</div>
<p>
	Para acceso aleatorio a un elemento | constante| \(O(l)\)
	<br>
	Insertar o remover un elemento al final del contenedor | constante | \(O(l)\)
	<br>
	Insertar o remover un elemento | lineal en función de la distancia a la que esté del final | \(O(n)\)
</p>

<div class="Subtitulo" id="3">
	Funciones miembro
</div>
<table class="Tabla">
	<tr>
		<th>Función</th>
		<th>Definición</th>
	</tr>
	<tr>
		<td>(constructor)</td>
		<td>Construye un contenedor <code>vector</code>, es lo que nos permite <i>declararlo</i>.</td>
	</tr>
	<tr>
		<td>(destructor)</td>
		<td>Destruye el <code>vector</code></td>
	</tr>
	<tr>
		<td>Operador <code>=</code></td>
		<td>Asigna valores al contenedor</td>
	</tr>
	<tr>
		<td><code>get_allocator</code></td>
		<td>Regresa el asignador asociado</td>
	</tr>
	<tr>
		<th colspan="2">Acceso a elementos</th>
	</tr>
	<tr>
		<td><code>at</code></td>
		<td>Accede al elemento especificado del contenedor con comprobación de límites</td>
	</tr>
	<tr>
		<td>Operador <code>[]</code></td>
		<td>Accede al elemento especificado</td>
	</tr>
	<tr>
		<td><code>front</code></td>
		<td>Accede al primer elemento del contenedor</td>
	</tr>
	<tr>
		<td><code>back</code></td>
		<td>Accede al último elemento del contenedor</td>
	</tr>
	<tr>
		<th colspan="2">Iteradores</th>
	</tr>
	<tr>
		<td><code>begin</code> <code>cbegin</code></td>
		<td>Devuelve un iterador al principio del contenedor</td>
	</tr>
	<tr>
		<td><code>end</code> <code>cend</code></td>
		<td>Devuelve un iterador al final del contenedor</td>
	</tr>
	<tr>
		<td><code>rbegin</code> <code>crbegin</code></td>
		<td>Devuelve un iterador reverso al principio del contenedor</td>
	</tr>
	<tr>
		<td><code>rend</code> <code>crend</code></td>
		<td>Devuelve un iterador reverso al final del contenedor</td>
	</tr>
	<tr>
		<th colspan="2">Capacidad</th>
	</tr>
	<tr>
		<td><code>empty</code></td>
		<td>Checa si el contenedor está vacío</td>
	</tr>
	<tr>
		<td><code>size</code></td>
		<td>Regresa el número de elementos en el contenedor</td>
	</tr>
	<tr>
		<td><code>max_size</code></td>
		<td>Regresa el máximo número posible de elementos</td>
	</tr>
	<tr>
		<td><code>reserve</code></td>
		<td>Reserva almacenamiento</td>
	</tr>
	<tr>
		<td><code>capacity</code></td>
		<td>Regresa el número de elementos que pueden ser almacenados en el contenedor con el espacio actual</td>
	</tr>
	<tr>
		<td><code>shrink_to_fit</code> (C++11)</td>
		<td>Reduce a memoria usada liberando el espacio no utilizado</td>
	</tr>
	<tr>
		<th colspan="2">Modificadores</th>
	</tr>
	<tr>
		<td><code>clear</code></td>
		<td>Limpia el contenido del contenedor</td>
	</tr>
	<tr>
		<td><code>insert</code></td>
		<td>Inserta elementos en el contenedor</td>
	</tr>
	<tr>
		<td><code>erase</code></td>
		<td>Borra elementos</td>
	</tr>
	<tr>
		<td><code>push_back</code></td>
		<td>Agrega un elemento al final del contenedor</td>
	</tr>
	<tr>
		<td><code>pop_back</code></td>
		<td>Quita el último elemento del contenedor</td>
	</tr>
	<tr>
		<td><code>resize</code></td>
		<td>Cambia la cantidad de elementos almacenados</td>
	</tr>
	<tr>
		<td><code>swap</code></td>
		<td>Intercambia el contenido</td>
	</tr>
</table>

<div class="Subtitulo" id="4">
	Funciones no miembro
</div>
<table class="Tabla">
	<tr>
		<th>Función</th>
		<td>Definición</td>
	</tr>
	<tr>
		<td>Operadores <code>==</code>, <code>!=</code>, <code><</code>, <code><=</code>, <code>></code>, <code>>=</code></td>
		<td>Compara lexicográficamente los valores de un vector</td>
	</tr>
</table>

<div class="Subtitulo" id="5">
	Ejemplo general
</div>

<textarea class="editor">
#include <iostream>
#include <vector> // Librería del contenedor
using namespace std;
	
int main(){
	/* --- Declaración --- */
    vector<int> v; // Declaración del vector, en este caso tipo entero
    vector<int> segundo {12, 5, 3, 14, 98, 56, 23, 45}; // Declaración e inicialización (requiere c++11)

    /* --- Asignación --- */
    v = segundo; // Copia de "segundo" en "v"
    // Sólo puede ser entre vectores, los valores del primer 
    // contenedor se sobreescribirán para poner los del segundo
    v.assign(4, 87);
  	// Borra todos los valores en v y almacena 4 veces el valor 87

    /* --- Acceso a elementos --- */
    cout << segundo.front() << '\n'; // Primer elemento
    cout << segundo.back() << '\n'; // Último elemento
    cout << segundo[3] << '\n'; // Cuarto elemento (específico)
    cout << segundo.at(1) << '\n'; // Segundo elemento (seguro)


    /* --- Recorrer el vector -- */
    for (int i : v) // Para todos los elementos dentro de v
    	cout << i << " "; // i tiene que ser del mismo tipo que los valores del vector
    // Este método sólo es compatible en C++11

    cout << '\n';

    // Método tradicional como en un arreglo normal 
    for (int i = 0; i < v.size(); i++)
    	cout << v[i] << " ";
    cout << '\n';

    // O de manera más confiable, usando .at()
    for (int i = 0; i < v.size(); i++)
    	cout << v.at(i) << " ";
    cout << '\n';

    /* --- Sobre capacidad --- */
    if (v.empty()) // Devuelve true si está vacío
    	cout << "v esta vacio\n";
    cout << v.size() << " " << segundo.size() << '\n'; // Cantidad de objetos en los contenedores
    cout << v.max_size() << '\n'; 
    // Maxima cantidad de elementos posibles en el vector v
    cout << v.capacity() << '\n';
    // Regresa el numero de elementos que se pueden almacenar con la memoria declarada

    /* --- Modificador clear --- */
    v.clear();
    // Borra todos los elementos del vector
    cout << v.size() << '\n';

    /* --- Modificador insert --- */
    v.insert(v.begin(), 14);
    // Inserta el 14 en el inicio del vector 
    v.insert(v.begin(), 25);
    // Inserta ahora el 25 también al inicio
    for (int i : v) cout << i << " ";
    cout << '\n';

    v.insert(v.begin()+2, segundo.begin(), segundo.end());
    // Inserta en v, después del segundo elemento, el contenido
    // de 'segundo' desde el inicio hasta el fin
    for (int i : v) cout << i << " ";
    cout << '\n';

    v.insert(v.begin(), 3, 200);
    // Se inserta 3 veces el 200 al inicio del contenedor
    for (int i : v) cout << i << " ";
    cout << '\n';

    int arreglo[] = { -12, -32, 99};
    v.insert(v.end(), arreglo, arreglo+2);
    // Se insertan al final del vector, los elementos de
    // 'arreglo', desde el inicio hasta el segundo elemento
    for (int i : v) cout << i << " ";
    cout << '\n';

    /* --- Modificador erase --- */
    segundo.erase(segundo.begin());
    // Eliminación del primer valor del vector
    for (int i : segundo) cout << i << " "; 
    cout << '\n';

    segundo.erase(segundo.begin()+2);
    // Eliminación del tercer arreglo del vector
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    segundo.erase(segundo.begin()+1, segundo.begin()+4);
    // Eliminación de un intervalo
    // El último elemento del intervalo no se borra
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    /* --- Modificador push_back --- */
    segundo.push_back(32);
    // Inserta al final del contenedor, el entero 32
    int variable = 15;
    segundo.push_back(variable);
    // Inserta al final la variable 'variable'
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    /* --- Modificador pop_back --- */
    segundo.pop_back();
    // Elimina el elemento del final
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    /* --- Modificador resize --- */
    segundo.resize(3);
    // Se borran todos los elementos dejando sólo los primeros 3
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    segundo.resize(6);
    // Cambia el tamaño a 6, si hay menos elementos entonces 
    // rellena con 0
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    /* --- Modificador swap -- */
    for (int i : v) cout << i << " ";
    cout << '\n';
    for (int i : segundo) cout << i << " ";
    cout << '\n';
    // Se muestran los contenidos
    v.swap(segundo);
    // Se intercambian contenidos 
    for (int i : v) cout << i << " ";
    cout << '\n';
    for (int i : segundo) cout << i << " ";
    cout << '\n';

    return 0;
}</textarea>
<p>
	Salida del anterior programa.
</p>
<textarea class="output">
12
45
14
5
87 87 87 87 
87 87 87 87 
87 87 87 87 
4 8
1073741823
8
0
25 14 
25 14 12 5 3 14 98 56 23 45 
200 200 200 25 14 12 5 3 14 98 56 23 45 
200 200 200 25 14 12 5 3 14 98 56 23 45 -12 -32 
5 3 14 98 56 23 45 
5 3 98 56 23 45 
5 23 45 
5 23 45 32 15 
5 23 45 32 
5 23 45 
5 23 45 0 0 0 
200 200 200 25 14 12 5 3 14 98 56 23 45 -12 -32 
5 23 45 0 0 0 
5 23 45 0 0 0 
200 200 200 25 14 12 5 3 14 98 56 23 45 -12 -32 
</textarea>

<p>
	No olvides examinar cuidadosamente el programa anterior y su comportamiento en tu <i>IDE</i> favorito.
</p>

<div class="Nav">
	<a href="{{ site.url }}/C++/STL/" id="NIzq">Tema anterior</a> | <a href="{{ site.url }}/C++/STL/String/" id="NDer">Tema siguiente</a>
</div>